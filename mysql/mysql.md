# mysql知识点汇总

## mysql基本架构
mysql主要分为server层和存储引擎层。而server层包括了连接器、查询缓存、分析器、优化器、执行器等。

server层包括了mysql大多数的核心功能，以及所有的内置函数(count,sum等)，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

存储引擎层则是负责数据的存储以及读取，支持 InnoDB、MyISAM、Memory 等多个存储引擎（架构模式是插件式的，所以mysql也可以自定义存储引擎来使用）。mysql5.5.5之前默认存储引擎为MyISAM，mysql5.5.5之后则是InnoDB。

其基本架构示意图如下所示：
![](https://img2022.cnblogs.com/blog/901559/202201/901559-20220130171301031-2030452943.jpg)

### server层
#### 连接器
连接器负责跟客户端建立连接、获取权限、维持和管理连接，也就是你用mysql客户端连接工具执行```mysql -u xxx -p xxx```命令。

连接器会校验你的用户名密码是否正确，成功建立连接后连接器会在权限表查询该用户所拥有的权限，之后执行的命令都需要根据此时读取到的权限来校验是否有权执行命令。（在修改用户权限之后，用户需要重新登录权限才能生效的原因就是在建立连接之后读取了账号权限，在断开连接之前都会用该权限来校验）

注意，成功建立连接后（长连接），mysql在执行过程中所申请的内存空间都是由连接对象管理的，这些资源只有在连接对象断开之后才会释放，所以如果连接长期不释放的话（排序、变量这些会占用内存），很容易就会造成内存溢出（客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时）。

长连接不提前释放内存的原因如果这个链接是要复用的，提前释放反而影响性能（因为要重新申请内存），MySQL没法自己决定，所以5.7之后提供了方法让客户端有命令```mysql_reset_connection()```来做

#### 查询缓存
建立连接后，你就可以执行mysql语句了，而在执行```select```语句的时候，会先去查询缓存里找，之前执行过的语句会在查询缓存里以key-value的形式保存起来（key是查询语句，value是查询结果），如果能知道对应的key，则直接返回查询结果，就不需要进行后续查询步骤了（如果命中查询缓存，会在查询缓存返回结果的时候做权限验证，没有权限就不会返回结果）。

不过查询缓存的命中率一般很低，特别是对应更新比较频繁的表，毕竟你一条update语句更新了表的数据，那么对应的缓存数据就全清空了，所以一般不建议使用查询缓存。正因如此，mysql8.0后直接就把查询缓存的整块功能给删掉了（8.0之前的版本只要将参数query_cache_type设置成0就可以不使用查询缓存）

##### query_cache_type
既然提到了这个参数，这里也解释一下：

- 0 关闭查询缓存
- 1 打开查询缓存
- 2 只有select 中明确指定SQL_CACHE才缓存，如：

	```select SQL_CACHE * from test where id = 1```

#### 分析器
如果查询缓存没有命中或者被关闭，那么就会执行sql语句，此时分析器会经过词法分析和语法分析这两个步骤进行处理(图中分析器->查询缓存的意思是，更新完数据后需要失效查询缓存【如果有】)。

##### 词法分析
词法分析就是识别你的sql里面的字符串分表代表什么，比如以下这条语句：

```select * from test where id = 1```

mysql会根据```select```关键字分析出这条语句是查询语句，```from```关键字后面跟着的是表名，```where```关键字后面跟着的就是查询条件。

##### 语法分析
做完词法分析后，mysql就会根据语法规则，检查你这条语句是否有满足sql的语法，表是否存在，列是否存在等，不满足则返回错误提示，如：

```MySQL server version for the right syntax to use near 'xxxx'``` 或者 ```Unknown column 'xxx'```

主要关注```use near```和```Unknown column```，一般这个后面就是提示mysql语句发生错误出现的第一个位置

#### 优化器
经过了分析器之后，检查了sql语句没有语法错误了，在执行之前，还需要优化器对sql进行优化。比如说：

```select * from test where aid = 1 and bid > 2```

test表里分别对aid和bid建立了索引，优化器就要对该条语句选择使用哪个索引。

又比如说:

```select * from test1 as t1 left join test2 as t2 on t1.id = t2.id where t1.aid = 10 and t2.bid = 20```

mysql优化器需要选择这个join语句哪个表作为驱动表(explain结果中，第一行出现的表就是驱动表)，根据驱动表的不同，执行效率会不同。

优化器是一个十分复杂的东西，后文会根据不同的例子，详细的说明优化器的内容，以及结合自身的经验如何优化sql语句。

#### 执行器
经过了语法校验和优化之后，就真正的开始执行sql语句了，在开始执行之前，会先校验权限，看登录用户是否有权执行这条sql（连接器已经取出用户的权限了，在执行器的时候才用来校验权限，既然连接器已经取出了权限，为啥不在优化器之前校验，原因是有些时候，SQL语句要操作的表不只是SQL字面上那些。比如如果有个触发器，得在执行器阶段（过程中）才能确定。优化器阶段前是检测不到的）

以```select * from test where id = 10```为例，如果id上没有索引，那么其执行流程如下所示：

1. 调用InnoDB引擎接口取这个表的第一行，判断id值是不是10，如果不是则跳过，如果是则将这行存在结果集中
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端

如果有索引，则是：

1. 调用InnoDB引擎接口取这个表满足条件的第一行
2. 调用引擎接口取“下一行”，直到下一行的id不为10则停止继续取出
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端

### 存储引擎层
在经过server层连接器，分析器，优化器，执行器等一系列过程之后，最后到达的就是存储引擎层，而存储引擎层主要是负责数据的读写，这里主要介绍的是innodb存储引擎。读就比较简单，找到数据直接返回就可以了，但写话，我们平时执行的update，insert语句，如何保证能成功写入呢？

#### innodb存储引擎的写入
虽说我们更新或者插入数据仅仅只是用一条sql就可以搞定了，看似简单，但是其流程却是经历一系列步骤，其详细流程如下图所示：
![](https://img2022.cnblogs.com/blog/901559/202202/901559-20220201162649518-315247849.png)

##### undo log
innodb每次对数据进行写入或者更新的时候，都会生成一个事务id（递增），根据执行的语句生成一个回滚数据的语句（如：insert语句就会生成delete语句，update语句就会生成重新更新回旧数据的update语句），将这个语句和事务id写入undo log，会得到一个回滚指针，然后更新对应数据行（比如id=2的这行数据）事务id和回滚指针，当事务需要回滚的时候，就可以根据事务回滚指针找到对应的回滚sql，进行旧数据的恢复（回滚操作）。除此之外，undo log 也通过事务id来判断事务的可见性，详情将会在事务隔离详细介绍

##### change buffer
change buffer 是用来优化二级且非唯一索引，且对应的数据页没在内存（buffer pool）中的数据插入和更新上的（简单来说就是优化为批量操作，而且对update操作来说还可以减轻从磁盘加载数据页的性能损耗）。

因为每次插入或者更新，假如对应的数据页不存在内存中，都需要从磁盘中把对应的数据页读取出来，然后再进行数据页的修改操作。

有了change buffer之后，假如遇到数据页不在内存中，且不影响数据的唯一性的情况下，那么可以先把数据写入到change buffer中，等对应的数据页被访问从而加载到内存中的时候，再把change buffer中对应的新数据修改到内存页中（称为merge操作），亦或者每隔一段时间，由后台线程定期的触发merge操作，这样就可以把若干对同一页面的更新缓存起来做，合并为一次性更新操作。（减少IO，转随机IO为顺序IO,这样可以避免随机IO带来性能损耗，提高数据库的写性能）

- 为什么数据页在内存中，不使用change buffer

	change buffer 其中一点优化就是为了不要每次更新都把数据从磁盘加载到内存中（对应的数据页不存在内存的情况下），既然数据页已经在内存中了，那么直接改就行了。

- 为什么数据唯一的时候，不使用change buffer

	因为每次唯一索引数据更新或者插入的时候，都需要判断数据的唯一性，不存在这个数据才能更新或者插入，在校验唯一性的过程中，不管怎样都需要把对应的数据页加载到内存中，既然数据页已经在内存中了，那么直接改就行了。

##### redo log

##### double write



## 事务隔离

## 索引

## 锁

